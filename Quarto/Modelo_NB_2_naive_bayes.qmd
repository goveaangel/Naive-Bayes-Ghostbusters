---
title: "Modelo de Clasificación Naive Bayes 2 (naive_bayes, Poisson)"
author: "Diego Vértiz Padilla, José Ángel Govea García, Augusto Ley Rodríguez, Daniel Alberto Sánchez Fortiz"
format:
   html:
     toc: true
     html-math-method: katex
     embed-resources: true
     self-contained-math: true
     df-print: kable
editor: source
---
```{r}
library(dplyr)
library(tm)             
library(naivebayes)      
library(syuzhet)         
library(caret)           
library(tibble)
library(janitor)
library(ggplot2)
library(tidyr)
```

```{r}
# ===== Helpers =====
metrics_from_cm <- function(cm){
  acc <- as.numeric(cm$overall["Accuracy"])
  byc <- cm$byClass
  if (is.null(dim(byc))) {
    precision <- as.numeric(byc["Pos Pred Value"])
    recall    <- as.numeric(byc["Sensitivity"])
    f1        <- 2 * (precision*recall) / (precision + recall)
  } else {
    ppv   <- byc[,"Pos Pred Value"]
    sens  <- byc[,"Sensitivity"]
    f1vec <- 2 * (ppv * sens) / (ppv + sens)
    precision <- mean(ppv,  na.rm=TRUE)
    recall    <- mean(sens, na.rm=TRUE)
    f1        <- mean(f1vec, na.rm=TRUE)
  }
  tibble(
    accuracy  = round(acc, 4),
    precision = round(precision, 4),
    recall    = round(recall, 4),
    f1_score  = round(f1, 4)
  )
}

fit_eval_nb <- function(Xmat, y, idx_tr, idx_te, use_pois = FALSE, tag = ""){
  Xtr <- as.matrix(Xmat[idx_tr, , drop=FALSE])
  Xte <- as.matrix(Xmat[idx_te, , drop=FALSE])
  ytr <- y[idx_tr]; yte <- y[idx_te]

  mod <- naive_bayes(x = Xtr, y = ytr, usepoisson = use_pois)
  pred <- predict(mod, Xte)
  cm   <- confusionMatrix(pred, yte)

  list(
    metrics = metrics_from_cm(cm) %>%
      mutate(modelo = tag,
             poisson = ifelse(use_pois, "Con Poisson", "Sin Poisson")),
    cmtbl   = tibble(Real = yte, Predicho = pred) %>%
      tabyl(Real, Predicho) %>%
      adorn_totals(c("row","col"))
  )
}
```

```{r}
# ===== 1) Cargar =====
dtm_path    <- "../data/dtm_sparse.rds"  
corpus_path <- "../data/corpus.rds"      
stopifnot(file.exists(dtm_path), file.exists(corpus_path))

dtm    <- readRDS(dtm_path)
corpus <- readRDS(corpus_path)

X_full <- as.data.frame(as.matrix(dtm), check.names = TRUE)
doc_ids <- rownames(X_full)
y <- factor(corpus$categoria[ match(doc_ids, corpus$doc_id) ])
keep <- !is.na(y)
X_full <- X_full[keep, , drop=FALSE]
y      <- y[keep]
doc_ids <- doc_ids[keep]

# NRC (10 columnas) alineado
nrc_all     <- get_nrc_sentiment(as.character(corpus$text))
nrc_use     <- nrc_all[ match(doc_ids, corpus$doc_id), , drop=FALSE]

# BOW reducido 
topN <- 800   
df_vec    <- colSums(X_full > 0) 
top_terms <- names(sort(df_vec, decreasing = TRUE))[1:min(topN, ncol(X_full))]
X_top     <- X_full[, top_terms, drop=FALSE]

# Combos
X_full_plus_nrc <- cbind(X_full, nrc_use)
X_top_plus_nrc  <- cbind(X_top,  nrc_use)

# ===== 2) Split 70/30  =====
set.seed(1234)
n <- nrow(X_full)
idx_tr <- sample.int(n, floor(0.7*n))
idx_te <- setdiff(seq_len(n), idx_tr)
```

```{r}
# ===== 3) Correr los 10 modelos =====
res <- list()

# 1) BOW completo
res[["BOW completo | Sin Poisson"]] <- fit_eval_nb(X_full, y, idx_tr, idx_te, FALSE, "BOW completo")
res[["BOW completo | Con Poisson"]] <- fit_eval_nb(X_full, y, idx_tr, idx_te, TRUE,  "BOW completo")

# 2) BOW reducido
res[["BOW TopN | Sin Poisson"]] <- fit_eval_nb(X_top, y, idx_tr, idx_te, FALSE, paste0("BOW Top-", length(top_terms)))
res[["BOW TopN | Con Poisson"]] <- fit_eval_nb(X_top, y, idx_tr, idx_te, TRUE,  paste0("BOW Top-", length(top_terms)))

# 3) Solo NRC
res[["NRC solo | Sin Poisson"]] <- fit_eval_nb(nrc_use, y, idx_tr, idx_te, FALSE, "NRC solo")
res[["NRC solo | Con Poisson"]] <- fit_eval_nb(nrc_use, y, idx_tr, idx_te, TRUE,  "NRC solo")

# 4) BOW completo + NRC
res[["BOW completo + NRC | Sin Poisson"]] <- fit_eval_nb(X_full_plus_nrc, y, idx_tr, idx_te, FALSE, "BOW completo + NRC")
res[["BOW completo + NRC | Con Poisson"]] <- fit_eval_nb(X_full_plus_nrc, y, idx_tr, idx_te, TRUE,  "BOW completo + NRC")

# 5) BOW reducido + NRC
res[["BOW TopN + NRC | Sin Poisson"]] <- fit_eval_nb(X_top_plus_nrc, y, idx_tr, idx_te, FALSE, paste0("BOW Top-", length(top_terms), " + NRC"))
res[["BOW TopN + NRC | Con Poisson"]] <- fit_eval_nb(X_top_plus_nrc, y, idx_tr, idx_te, TRUE,  paste0("BOW Top-", length(top_terms), " + NRC"))

# ===== 4) Tabla comparativa =====
metrics_df <- bind_rows(lapply(res, `[[`, "metrics"))
metrics_df <- metrics_df %>%
  relocate(modelo, poisson) %>%
  arrange(desc(accuracy))
metrics_df
```

```{r}
# ===== 5) Gráfica de métricas =====
metrics_long <- metrics_df %>%
  pivot_longer(cols = c(accuracy, precision, recall, f1_score),
               names_to = "metric", values_to = "value")

ggplot(metrics_long, aes(x = metric, y = value, fill = interaction(modelo, poisson, sep=" | "))) +
  geom_col(position = position_dodge(width = 0.8)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(title = "Métricas por modelo (naivebayes)",
       x = "Métrica", y = "Valor (proporción)", fill = "Modelo | Poisson") +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.text.x = element_text(size = 11))
```

```{r}
# ===== 6) Heatmap de la matriz de confusión del MEJOR modelo =====
best_idx <- which.max(metrics_df$accuracy)
best_key <- rownames(metrics_df)[best_idx]  
best_tbl <- res[[best_idx]]$cmtbl



cm_long <- best_tbl %>%
  filter(Real != "Total") %>%
  pivot_longer(-Real, names_to = "Predicho", values_to = "Casos") %>%
  filter(Predicho != "Total")

# ordenar ejes por frecuencia
ord_real <- cm_long %>% group_by(Real) %>% summarise(n = sum(Casos)) %>% arrange(desc(n)) %>% pull(Real)
ord_pred <- cm_long %>% group_by(Predicho) %>% summarise(n = sum(Casos)) %>% arrange(desc(n)) %>% pull(Predicho)
cm_long$Real     <- factor(cm_long$Real, levels = ord_real)
cm_long$Predicho <- factor(cm_long$Predicho, levels = ord_pred)

ggplot(cm_long, aes(x = Predicho, y = Real, fill = Casos)) +
  geom_tile() +
  geom_text(aes(label = Casos), size = 4) +
  scale_fill_gradient(low = "#f0f9e8", high = "#0868ac") +
  labs(title = paste0("Matriz de confusión (mejor: ", best_key, ")"),
       x = "Predicho", y = "Real", fill = "Casos") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


